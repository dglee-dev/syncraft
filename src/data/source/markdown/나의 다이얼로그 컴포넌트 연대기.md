---
title: 나의 다이얼로그 컴포넌트 연대기
category: tech
---


# 나의 다이얼로그 컴포넌트 연대기

오늘의 주제는 다이얼로그 컴포넌트입니다.

<img src="https://justin-cms-images.s3.ap-northeast-2.amazonaws.com/dialog_material_design_152624cbb9.png" style="width: 100%" />

최근에 이런저런 과제들도 하고 공부를 하면서 이 다이얼로그 컴포넌트의 구현에 대해 깨달은 것들이 있어서 제가 그동안 만들어온 다이얼로그 컴포넌트들의 변천사를 살펴보려고 하는데요, 역지사지의 마음을 가지고 제가 만들었던 다이얼로그 컴포넌트를 사용해야하는 개발자분들의 경험을 중심으로 이것이 어떻게 더 나아질 수 있는지 이야기 해볼까 합니다.

때는 바야흐로 2021년으로 거슬러 올라갑니다. 크라우드 에듀케이션(바닐라코딩의 법인)의 [퍼즐게임 앱](https://play.google.com/store/apps/details?id=com.crowd.wordie)을 만들며 게임 진행시에 필요한 다이얼로그 컴포넌트가 필요했습니다.

당시에는 '다이얼로그' 라는 명칭을 몰라서, (사실 최근까지도 몰랐습니다) `systemModal` 이라는 이름으로 구현을 하였습니다. 모달이긴 한데 시스템 내부적인 일들을 담당한다는 느낌으로요.

[Quora의 한 답변](https://qr.ae/pyl2z7)을 확인하면 Modal은 사용자가 꼭 하고 넘어가야 하는 일들을 요청하고, Dialog는 무시할수도 있는 일들을 요청한다는 차이점을 가진다고 합니다. 이러한 기준을 따른다면 제가 사용했던 systemModal은 다이얼로그라고 불릴 수 있을 것 같습니다.

아무튼, 먼저 당시 작성했던 코드를 살펴보겠습니다.
제가 만들었던 코드를 이용해 하나의 다이얼로그를 띄워주려면 아래와 같은 코드를 작성해야 했습니다.

```tsx
setSystemModal({
  ...systemModalVar(),
  title: "연습게임 클리어 🎉",
  isVisible: true,
  description:
    "연습게임을 클리어 하셨습니다. 이제 실전모드를 플레이 할 수 있습니다!",
  leftButtonText: "",
  rightButtonText: "플레이하기",
  rightButtonHandler: () => {
    setSystemModal({
      ...systemModalVar(),
      isVisible: false,
    });
  },
});
```

여러분들이 이 코드를 직접 작성해야 한다면 어떤 생각이 드실 것 같나요?

상태를 업데이트하여 다이얼로그(여기에서는 systemModal) 띄울 수 있구나라고 알 수 있습니다.
사용하는데에 큰 문제는 없겠지만, 지금 생각해보면 몇 가지 논점이 있습니다.

- 각각의 상태와 관련된 컴포넌트들의 생김새와 위계구조를 알지 못한 채로 코드만을 확인했을 때, 한 눈에 어떤 다이얼로그가 보여질지 예상하기 어렵습니다. 조금은 지나친 추상화 때문입니다.
- 새로운 디자인의 다이얼로그 컨텐츠를 추가하기 위해서는 매번 SystemModal의 내부에 작성된 컴포넌트와 상태 변경 로직들을 새로 만들거나 수정해야하는 불편함이 존재합니다.
- 모든 변경 가능한 UI를 상태로 관리하기 때문에, 상태를 제대로 업데이트하지 못하거나 이전에 사용했던 상태가 남아있게 되면 예측할 수 없는 형태로 모달이 작동될 수 있는 가능성이 존재합니다.

3번의 문제는 useReducer 훅을 사용해 리듀서를 작성하고 액션으로 상태 업데이트를 추상화 해 두면 다이얼로그를 상태로 관리하는 것으로 유지하면서도 문제를 해결할 수 있습니다. 보여지는 UI의 경우의 수가 많지 않다면 1번의 문제도 나름대로 해결될 수 있습니다.

2번 문제가 이 구현의 가장 큰 약점입니다. 한 마디로 확장에 유연하지 않은 구조입니다. 다이얼로그의 형태가 버튼이 한두개 있거나 없는 배리에이션을 갖는다면 지금과 같이 상태의 업데이트를 통해 조건적으로 UI를 조정하는 것이 가능하지만, 조금만 더 다양한 형태의 내부 컨텐츠를 구현해야 하는 경우에는 `<SystemModal />` 컴포넌트의 종류를 여러개로 나누어 사용할 수 밖에 없을겁니다.

실제로 그렇게 구현해 사용했던 다른 예시를 확인해보겠습니다. 이번에는 2022년 [찹스틱스](https://chopsticks.market) 에서 근무하며 작성했던 코드입니다.

내부 컨텐츠의 배리에이션을 커버하기 위해 SystemModal과 Modal로 구분해서 사용했었고, 각각의 상태가 따로 존재합니다. SystemModal은 3가지 정도의 버튼에 대한 배리에이션을 가지는 경우들을 커버할 수 있는 용도로 사용했으며 Modal은 이외의 컨텐츠가 자유롭게 주입될 수 있는 용도로 사용되었습니다.

첫번째가 SystemModal, 두번째가 Modal 컴포넌트의 코드입니다.

```tsx
// SystemModal.tsx
<Container>
  {title && <Title>{title}</Title>}

  <Contents hasTitle={Boolean(title)}>{contents}</Contents>

  <ButtonWrapper>
    {redirectTo ? (
      <RedirectButton onClick={handleRedirectButtonClick}>
        {redirectMessage || "홈으로 돌아가기"}
      </RedirectButton>
    ) : (
      <>
        <CancelButton onClick={cancelButtonClickHandler}>
          {cancelButtonText ?? "아니오"}
        </CancelButton>
        <ConfirmButton onClick={confirmButtonClickHandler}>
          {confirmButtonText ?? "예"}
        </ConfirmButton>
      </>
    )}
  </ButtonWrapper>
</Container>
```

```tsx
// Modal.tsx
<Container isDisappearing={!isVisible}>
  <Contents>{contents}</Contents>
 </Container>
```

두개 컴포넌트의 `Container` 스타일은 동일합니다. 모양새로 생각해 보았을 때는, 두 컴포넌트가 분리될 이유가 없지만 컨텐츠가 얼마나 다양한 경우를 처리해야하느냐 라는 이유로 하나는 비교적 자주 사용되는 형태를 추상화 해 사용하는 것이며 (SystemModal), 다른 하나는 완전히 자유롭게 사용될 수 있도록 만들어 진 것입니다.

나름대로 타당한 구현이지만 SystemModal의 내부 레이아웃이 더 많은 배리에이션을 갖게 되면 SystemModal 내부의 코드는 훨씬 복잡한 조건문들로 구성되어야 할 것이고 상태를 업데이트하는 인터페이스 또한 복잡하게 될 것 같습니다.

이 문제를 해결하려면 `의존성을 역전` 시켜야만 합니다.

의존성이란 무엇일까요? 무언가를 만들 때 우리는 재료나 도구에 의존합니다. 제가 만든 SystemModal 이라는 이름의 다이얼로그는 내부적으로 `<Title>`, `<Contents>`, `<RedirectButton>`, `<ConfirmButton>`, `<CancelButton>` 라는 재료들에 의존하고 있습니다. 이것들이 없으면 SystemModal 의 내부는 텅텅 비게 될 것입니다.

그런데 이 의존성이 지금처럼 존재하는 것은 SystemModal 의 한계를 규정합니다. 앞에서 말했듯 미리 조건적으로 정의된 상황에서만 사용할 수 있는겁니다. 이런 상황에서, SystemModal을 더 자유롭게 사용할 수 있게 하기 위해 이 녀석이 의존하고 있는 하위 구성요소들을 `주입` 할 수 있도록 만듭니다.

먼저 코드로 살펴봅시다.

```tsx
// SystemModal.tsx
...
return (
  <Container>
    {children}
  </Container>
);
```

```tsx
// how to use
setSystemModal({
  contents: <>
    <SystemModal.Title>상품을 삭제할까요?</SystemModal.Title>
    <SystemModal.Button onClick={...} >예</SystemModal.Button>
    <SystemModal.Button onClick={...}>아니오</SystemModal.Button>
  </>
})
```

무엇이 바뀌었을까요?

SystemModal 은 더 이상 내부에 내용을 미리 가지고있지 않습니다. 대신 이것을 불러오려는 개발자가 어떤 내부를 구성하고 싶은지 직접 컴포넌트로 작성합니다. 당연히 더 유연하게 사용될 수 있습니다. 맥도날드에서 제공하는 10여가지의 메뉴만을 주문할 수 있다가, 직접 맥도날드의 재료들을 가지고 원하는 메뉴를 만들어먹게 된 겁니다.

그리고 바뀐 SystemModal을 바라보면, 기존에 구현되어 있던 Modal 컴포넌트와 그 구현이 일치하는 것을 확인할 수 있습니다. 두 가지 컴포넌트가 동시에 사용되는 일이 없다면 하나의 컴포넌트로 통합할 수도 있게 되었습니다.

그렇습니다. SystemModal을 사용하는 시점에 의존성을 주입(Dependency Injection)할 수 있게 만드는 것으로, 의존성 역전(Dependency Inversion)이라는 목표를 달성했고, 우리가 의존성을 역전시키려고 했던 이유는 추상화 된 구현을 더 유연하게 사용할 수 있게끔 하기 위함이였습니다. 맥도날드에서 메뉴를 고르는 것이 아니라 재료를 골라 만들어 먹을 수 있게 되었으므로 훨씬 유연해진 것을 알 수 있었습니다. 목표를 달성했습니다.

마지막으로 이러한 의존성 역전등을 이용해 유연하게 구현되어있는 Headless UI component 라이브러리 Radix UI 를 추천하며 글을 마무리해볼까 합니다. Radix에서 제공하는 Dialog 컴포넌트를 활용하는 코드는 다음과 같습니다. 제가 마지막으로 구현한 것과 매우 비슷한 형태임을 확인할 수 있습니다.

```tsx
import * as Dialog from '@radix-ui/react-dialog';

export default () => (
  <Dialog.Root>
    <Dialog.Trigger />
    <Dialog.Portal>
      <Dialog.Overlay />
      <Dialog.Content>
        <Dialog.Title />
        <Dialog.Description />
        <Dialog.Close />
      </Dialog.Content>
    </Dialog.Portal>
  </Dialog.Root>
);
```

간단한 다이얼로그 연대기였습니다.

---

- [Radix UI - dialog component](https://www.radix-ui.com/primitives/docs/components/dialog)

- 카카오 엔터 FE 기술블로그에서 발행한 [프론트엔드와 SOLID 원칙](https://fe-developers.kakaoent.com/2023/230330-frontend-solid/)을 읽으며 의존성 역전에 대한 부분을 많이 배웠고 적용해 볼 수 있었습니다.

- 토스에서도 `useOverlay` 라는 이름으로 다이얼로그를 사용할 수 있는 공개된 구현이 존재합니다. [깃허브](https://github.com/toss/slash/tree/main/packages/react/use-overlay)에서 소스를 확인할 수 있고, [문서](https://slash.page/ko/libraries/react/use-overlay/src/useoverlay.i18n/)도 있고 관련된 [블로그 글](https://toss.tech/article/frontend-declarative-code)도 있네요.

관련된 글들을 velog에서도 찾을 수 있었습니다.

- [Toss/Slash useOverlay 훅 분석해보기](https://velog.io/@juicyaloe/TossSlash-useOverlay-%ED%9B%85-%EB%B6%84%EC%84%9D%ED%95%B4%EB%B3%B4%EA%B8%B0-React)

- [팀원들이 사용하기 편한 Modal 컴포넌트를 만들자](https://velog.io/@chaeerim/%ED%8C%80%EC%9B%90%EB%93%A4%EC%9D%B4-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0-%ED%8E%B8%ED%95%9C-Modal-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EB%A5%BC-%EB%A7%8C%EB%93%A4%EC%9E%90)