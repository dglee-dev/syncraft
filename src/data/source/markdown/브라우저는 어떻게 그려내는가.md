---
title: 브라우저는 어떻게 그려내는가
category: tech
---


# 브라우저는 어떻게 그려내는가

내 블로그 `justindglee.com` 을 예시로 사용해본다.

먼저 사용자는 `justindglee.com` 을 주소창에 입력할 것이고, 브라우저는 해당 주소로 요청을 보낸다. 이 주소는 대부분 서버의 IP Adress를 검색해주는 도메인 서버를 향한다. 해당 도메인을 이용하기 위해 사용한 Godaddy에서 확인해보면, 이 도메인의 a record ( "A" stands for "address")는 아래와 같다.

![](https://velog.velcdn.com/images/nninnnin7/post/ae4d3c68-65dc-42bb-8c26-13920230f263/image.png)

이는 내가 사용하는 justindglee.com 라는 도메인이 75.2.60.5 라는 IP를 가리키고 있음을 의미한다.

내 블로그는 netlify로 배포되어 있고, 이것은 netlify의 로드밸런서를 가리킨다. netlify는 브라우저로부터의 요청을 받아 로드밸런서를 통해 비교적 널널한 서버로 요청을 보낼것이고, 서버에서 처리된 요청은 `justindglee.com/~` 으로 요청을 보낸 브라우저에게 응답으로서 HTML 문서를 되돌려 줄 것이다.

---

과연 HTML 문서는 어떻게 네트워크를 통해 브라우저로 전송될까?

wireshark를 켜고 사용중인 wifi를 선택한 다음 네트워크 요청을 일으켜본다. 

![](https://velog.velcdn.com/images/nninnnin7/post/5f5444d1-6271-4687-b056-1474cbca8490/image.png)

나의 아이피 192.*\*\(Destination)에서 75.2.60.5(Source)로의 요청이 잡힌다. 패킷을 확인할 수 있지만 암호화가 되어있는 듯 하고 (Encrypted Application Data) 여기에서 HTML을 분리해내어 직접 파싱해보는 경험은 지금으로서는 가성비가 안맞는 듯 하므로-넘어간다.

상기의 과정을 통해, 브라우저는 HTML을 받는다.

여기까지는 서버와 브라우저 사이의 이야기.

---

이제는 브라우저만의 이야기.

HTML을 받은 브라우저는 크게 parsing - rendering 의 과정을 거쳐 사용자로 하여금 시각적으로 HTML의 내용을 확인할 수 있도록 만들어준다.

이 parsing과 rendering의 과정은 크게 5단계로 이루어져 있으며, "Critical Render Path(CRP)" 라 불린다.

![CRP](https://images.velog.io/images/nninnnin7/post/aeb1b5f0-7c90-463d-af89-68b05b8b692b/image.png)

### 1. parsing HTML: tokenizing and DOM Tree construction

이 HTML을 브라우저는 '토큰' 단위로 나눈다. 이 과정을 토크나이징이라고 말한다고 한다.

토크나이징 된 HTML 정보는 트리형태인 DOM tree로 변환된다. 토큰간의 위계를 구성하는 것이다.

HTML이 DOM tree로 파싱되는 동시에, 중간에 image나 css, 또는 javascript를 요청하는 코드를 만난다면 - link/script태그일테다 - , image 또는 css는 파싱을 막지 않고 리소스를 요청하거나 CSSOM을 생성한다. 하지만 자바스크립트를 만났다면, async나 defer가 명시되어있지 않는 이상 파싱 작업을 막는다.

브라우저 메인스레드에서 DOM tree를 생성하는 동안 'preload scanner' 라는 녀석이 이미지나 CSS, 폰트, JS와 같이 중요한 리소스들을 미리 요청해 가져온다.

### 2. processing CSS: build CSSOM Tree

CSSOM을 생성하는 것은 굉장히, DNS lookup보다 빠르기 때문에 최적화에 그다지 많이 신경을 써야하는 부분은 아니다.

여기까지는 Parsing, 즉 HTML의 해석과 관련된 이야기. 3-5는 Rendering, 해석된 내용을 그려내기 위한 과정이다.

### 3. Combining Trees: Render Tree

헤드, 스크립트 태그나 display: none을 가진 태그들은 렌더트리에 포함되지 않는다. 그들은 렌더링되지 않기 때문!

### 4. Layout: compute the geometry of nodes

엘리먼트의 사이즈, 포지션 등이 정해지는 단계이고, 이후 이 사이즈나 포지션 등에 변경이 생길 때 일어나는 일은 'Reflow' 라고 칭해진다.

### 5. Paint: drawing visuals

화면에 그려내는 작업이다. FMP, First Meaningful Paint라는 지표가 존재한다만 크롬에서는 라이트하우스6.0 에서 이 지표를 deprecated 시켰다고 하는데, 표준화되기 어려운 예민한 지표이기 때문이라고 한다. [참고](https://developer.chrome.com/en/docs/lighthouse/performance/first-meaningful-paint/)

하나 예를 들자면, 만약 이미지의 크기를 정해두었다면, 이미지가 로딩되기 전에도 해당 이미지의 크기만큼 브라우저는 레이아웃을 정해둔 상태일 것이다. 그러나 크기가 정해지지 않았다면, 이미지의 로딩 후 브라우저는 레이아웃을 'reflow' 해야 한다. 따라서 만일 이미지의 크기를 미리 정해두었다면 reflow는 일어나지 않고 repaint만 일어나게 된다.

---

보통 우리는 배우기 위해 1-5 단계를 순차적으로 써보거나 읽어보지만, 실제로 개발을 하거나 사용자로서 브라우저의 화면을 접할때에는 거꾸로 생각하는 것이 좋을 것 같다.

화면을 보기 위해서는 페인팅이 필요하고, 페인팅을 위해서는 '어떤 위치에 무엇이 어떻게 그려져야 하는가' 를 알아야 할 것이다. 그리고 '어떤 위치에 무엇이 어떻게' 를 알기 위해서는 이들의 위계구조와 각각의 스타일링이 어떻게 되어야 하는지를 알아야만 하고, 이것이 바로 Render Tree일 것이다. 렌더 트리는 '어떤 위치 + 어떻게' 에 해당하는 CSSOM Tree와 '무엇이' 와 위계구조에 해당하는 DOM Tree로 구성되고, 이것들을 구성하기 위해서는 구성요소가 무엇인지를 먼저 인식해야 하므로 HTML string을 tokenzing 해서 각각의 유닛으로 쪼개주어야 할 것이다.

> When a browser is tokenizing HTML, the input is typically treated as a sequence of characters, making it a string. HTML source code is essentially a text-based markup language that consists of tags, attributes, and content, all of which are represented using characters. As the browser processes the HTML source code, it parses the string into meaningful tokens, such as opening tags, closing tags, attributes, and text content.
>
> Tokenization is an early step in the parsing process where the HTML source code is broken down into a stream of tokens. These tokens are later used by the browser's rendering engine to construct the Document Object Model (DOM) and render the web page accordingly.
>
> While the HTML source code is treated as a string during tokenization, it's worth noting that modern browsers use various internal data structures and optimizations to efficiently handle and render HTML and other web content. These internal representations may use binary formats for performance reasons, but the initial input when tokenizing is still a string.

브라우저에서는 이 HTML을 서버로부터 가져와야만 할 것이고, 서버에서는 '얼마나 렌더링에 필요한 작업이 완료된 HTML을 줄 것인가?' 를 결정할 수 있을 것이다. SSR에 대한 이야기이다. 클라이언트에서 렌더링을 최적화하기 위해 필요한 요소들을 파악했으니, 남은 것은 서버의 것들과 클라이언트에서 해당 요소들을 어떻게 측정하고 개선할 수 있는지, 실제로 어떻게 사용되며 어떤 효과들이 존재하는지에 대한 조사 혹은 실습을 진행할 수 있을 것이다.

---

[MDN - How browsers work?](https://developer.mozilla.org/en-US/docs/Web/Performance/How_browsers_work)
