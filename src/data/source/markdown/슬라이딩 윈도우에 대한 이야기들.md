---
title: 슬라이딩 윈도우에 대한 이야기들
category: tech
---


# 슬라이딩 윈도우에 대한 이야기들

움직이는 창문과 같이 작동하는`슬라이딩 윈도우 알고리즘`에 대해 알아보자.

<img src="https://justin-cms-images.s3.ap-northeast-2.amazonaws.com/sliding-windows.jpeg" 
 style="width:100%" />

먼저 짚고 넘어갈 점은 '슬라이딩 윈도우' 와 '투포인터' 는 다르다. 슬라이딩 윈도우는 fixed window를 사용하는 탐색 방식이고, 투포인터는 subarray의 크기가 고정되어있지 않다. 그러나 보통 슬라이딩 윈도우를 말할 때 투포인터의 접근방식을 뭉뚱그려  이야기하는 경우가 많다고 한다. 해당 글과 이어지는 슬라이딩 윈도우와 관련된 글들에서도 투포인터와 고정된 투포인터, 즉 슬라이딩 윈도우를 함께 다룰 예정이다.

중요한 것은 이 알고리즘들은 효율적으로 sequential data를 탐색하기 위해 사용된다는 점이다. 이들은 `O(n)`의 시간복잡도를 가진 알고리즘인데, 만일 n개의 원소를 가진 배열의 모든 subarray를 탐색하는 경우의 수를 따져보자면 길이 1의 subarray는 n개, 길이 2의 subarray는 n-1개, ...이를 수식으로 표현한다면 아래와 같을 것이다.

> n + (n - 1) + (n - 2) + ... + 1

이는 우리가 익히 알고있는 등차수열의 합 공식에 따라 `n(n+1) / 2` 로 정리될 수 있으며, 따라서 단순히 모든 subarray를 탐색하는 알고리즘의 시간복잡도는 `O(n^2)` 임을 알 수 있다. 이와 비교해 `O(n)`은 매우 효율적인 시간복잡도를 자랑한다.

---

다음과 같은 문제가 있다고 해보자.

> find the longest subarray with a sum less than or equal to k

음수가 섞여있는 배열에서는 'with a sum less than k' 를 만족하는 subarray를 탐색할 때 왼쪽 포인터를 섣불리 오른쪽으로 옮길 수 없다. 만약 k를 넘는 합을 가진 subarray라 하더라도 오른쪽 포인터가 옮겨감에 따라 결과가 뒤바뀔 수 있기 때문이다. 이 경우 왼쪽 포인터는 오른쪽 포인터가 배열의 끝까지 탐색하기 전까지는 옮겨갈 수 없기 때문에, 왼쪽의 포인터가 무의미해질 것이고 원하는 결과를 찾을 때까지 반복적으로 subarray를 탐색하는 브루트포스 알고리즘을 사용해야 할 것이다.

반면, 만약 배열의 모든 원소가 양수라면 오른쪽 포인터가 옮겨갈수록 합은 더 커지기만 하기 때문에 조건보다 큰 값이 되었을 때에 미리 왼쪽 포인터를 옮길 수 있다. 이것은 양측의 포인터를 움직이며 탐색하기 때문에 투포인터라고 불리기에 적합하다. 

```
function fn(nums, k):
    left = 0
    curr = 0
    answer = 0

    for (int right = 0; right < nums.length; right++):
        curr += nums[right]

        while (curr > k):
            curr -= nums[left]
            left++

        answer = max(answer, right - left + 1)

    return answer
```

for 내부에 왼쪽 포인터를 옮겨주기 위한 while이 작성되어 있는 것을 확인할 수 있는데, 이것이 O(n^2) 시간복잡도로 해석되지 않는 이유는 left는 계속해서 커지기만 하고 `curr > k` 조건에 의해 오른쪽 포인터보다 커질 수 없기 때문이다. 따라서 for loop 전체에서 해당 로직이 반복적으로 실행되는 것이 아니라 최악의 경우 하나의 추가적인 O(n)으로 추산되어 O(2n)으로 계산될 것이다.

