---
title: 슬라이딩 윈도우의 사용 2
category: tech
---


# 슬라이딩 윈도우의 사용 2

> Given an array of positive integers `nums` and integer `k`, return the number of subarrays where the product of all the elements in the subarray is strictly less than `k`.\
(product는 곱셈을 의미한다)\
\
For example, given the input `nums = [10, 5, 2, 6], k = 100`, the answer is 8.\
The subarrays with products less than `k` are:\
`[10], [5], [2], [6], [10, 5], [5, 2], [2, 6], [5, 2, 6]`

이번에는 조건을 만족하는 subarray의 '갯수' 를 구하라고 한다.

```
function subarrayProductLessThanK (nums, k) {
  if (k <= 1) return 0; // k가 1 이하라면 곱의 결과가 0이어야 하는데, nums에는 양수만 있으므로

  let totalValidSubarray = 0;
  let productOfSubarray = 0;

  let left = 0;
  for (let right = 0; right < nums.length; right++) {
    productOfSubarray *= nums[right];

    while (productOfSubarray >= k) {
      productOfSubarray /= nums[left];
      left++;
    }

    const numberOfValidSubarray = right - left + 1;

    totalValidSubarray += numberOfValidSubarray;    
  }
}
```

주목할만한 점은 `numberOfValidSubarray` 를 계산하는 부분이다.
`numberOfValidSubarray`는 말 그대로 `productOfSubarray >= k` 조건을 만족하는 suarray의 갯수를 의미하는데, 이것이 어떻게 `right - left + 1`로 표현될 수 있는걸까?

`right - left + 1` 을 계산하는 시점의 `left`와 `right`가 무엇을 가리키는지 생각해보자. 각각의 포인터는 현재 찾아낸 valid한 subarray를 의미한다. 그러나 우리는 조건을 만족하는 '모든 subarray' 의 갯수를 세어야 하는 반면 해당 시점의 valid subarray는 오른쪽 포인터를 고정한 채로(for loop) 왼쪽 포인터를 옮겨내어 찾아낸(while loop) '오른쪽 포인터를 고정한 채로 찾아낼 수 있는 valid subarray중 가장 긴' 하나의 subarray 이다.

그런데 생각해보면, 해당 탐색(오른쪽 포인터를 고정시킨 상황)에서 추가적으로 찾아낼 수 있었던 valid subarray는 왼쪽 포인터를 오른쪽 포인터와 만나는 시점까지 옮기며 만들어낸 subarray들이다. 원소가 줄어들수록 곱한 값도 줄어들 수 밖에 없는 것은 물론이고 오른쪽을 고정시킨채로 왼쪽만 오른쪽으로 옮긴다면 이후의 탐색에서도 중복되는 subarray는 존재하지 않는다.

그러므로 `right - left + 1`은 오른쪽 포인터를 고정시킨 채로 왼쪽 포인터를 옮기며 찾아낼 수 있는 valid subarray를 모두 세어낸 값이 된다.