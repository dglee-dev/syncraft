---
title: 쓰기쉽고 읽기좋은 함수형 프로그래밍
category: tech
---


# 쓰기쉽고 읽기좋은 함수형 프로그래밍

인프런에서 제공되는 [유인동님의 강의](https://www.inflearn.com/course/functional-es6)를 들으며 정리해봅니다.

예제를 재미있게 활용해보거나 강의 중 등장하는 제가 잘 모르는 개념들도 함께 정리해보겠습니다.

## 함수형 프로그래밍 기본기

### 일급 객체로서의 함수

'일급' 은 인자로 들어가거나 결과로 리턴될 수 있고, 변수에 할당될 수 있다.

왜 '일급' 이라 부르는 걸까, 궁금해서 [찾아보니](https://stackoverflow.com/questions/245192/what-are-first-class-objects)

| In short, it means \*there are no restrictions on the object's use.

아하, _사용에 제한이 없기에_ 일급이다, _가장 자유롭게 사용할 수 있는 등급을 가졌기에_ 일급 이다. 라고 이해할 수 있었다.

### 고차 함수

크게 두 가지가 있다.

#### 1. 함수를 인자로 받아서 실행하는 함수

```
const nthLover = (n) => console.log(`너는 내 ${n}번째 사랑`);

const apply1 = (f) => {
  f(1);
}

apply1(nthLover); // 고차함수를 이용해 1번째 사랑임을 가독성 높은 형태로 표현할 수 있다.

const times = (f, n) => {
  let i = -1; // 왜 -1일까?

  while (++i < n) { // 1을 더하면서 시작하기 때문이다. 오퍼레이션 이후 더하는 것보다 가독성이 좋기 때문일까?
    f(i);
  }
}

times(nthLover, 10); // 고차함수를 이용해 10번의 연애를 가독성 높고 편리하게(..) 진행할 수 있다.
```

#### 2. 함수를 만들어 리턴하는 함수

```

// 호출되는 순간 리턴되는 함수는 n을 기억한다
const applyN = (n) => (f) => {
  f(n);
}

const apply10 = applyN(10); // 호출 시에 리턴되는 함수는 10을 기억한다

const add20 = (n) => n + 20;

apply10(add20); // add20에 10이라는 인자를 적용한다, 로 읽을 수 있다

```

## 이터러블:이터레이터 프로토콜

### ES6에서의 리스트 순회

for ++i 에서 for of 로. 이것이 단순 신택스 슈가이외에 어떤 의미가 있는가?

- Array, Set, Map을 모두 순회할 수 있는 `for of` 는 어떻게 추상화되어 있는가?

키로 데이터에 접근할 수 있는 Array와 달리 Set, Map은 set등의 메서드를 사용해야만 한다. 그런데 어떻게 `for of` 구문은 이들을 동일하게 순회할까?

- Array, Set, Map을 Symbol.iterator 라는 키로 참조해보면?

`이터레이터` 를 호출할 수 있는 함수가 리턴된다. 그리고 이런 함수를 `Symbol.iterator` 키로 참조할 수 있도록 가지고 있는 객체를 `이터러블` (객체) 라고 부를 수 있다!

- 이터레이터?

이터레이터 객체는 `next` 라는 메서드를 가지고 있고, 이를 호출하면 `{ value: unknown, done: boolean }` 이라는 결과를 반환한다.
next를 반복하면 이터러블의 값을 순차적으로 반환하기에 순회 상태를 저장하는 소모성 객체라고 말할 수 있다.

```

const arr = [1, 2, 3];

const iterator = arr[Symbol.iterator]();

iterator.next(); // { value: 1, done: false }
iterator.next(); // { value: 2, done: false }
iterator.next(); // { value: 3, done: false }
iterator.next(); // { value: undefined, done: true }

```

- 사용자 정의 이터러블

```
const iterable = {
  [Symbol.iterator] () {
    const iterator = {
      let i = 3;

      next() {
        return i == 0 ? { done: true } : { value: i--, done: false };
      }
    };

    return iterator;
  }

  let iterator = iterable[Symbol.iterator]();
}
```

자, 그러나 우리가 만든 이터러블은 미완이다.

무엇이 차이냐면, 반환하는 이터레이터의 퀄리티(!)에서 차이가 난다.

우리가 만든 이터러블에서 반환하는 이터레이터는,

- (이터러블이 아닌) '이터레이터' 를 `for of` 의 대상으로 넘겼을 때 순회가 불가능하며
- 이터레이터에서 순회를 진행시킨 상태를 저장하지 않기 때문에 미리 next를 호출하고 순회해도 처음부터 모든 값을 순회한다.

말을 바꿔서 오리지널 이터러블이 반환하는 오리지널 이터레이터(..)는, (인동님은 `well-formed iterator` 라는 단어를 사용)

- 이터레이터 그 자신조차 이터러블이다. 즉, 이터레이터를 Symbol.iterator로 참조하면 그 자신을 반환한다. 따라서 이터레이터를 `for of` 의 대상으로 넘겨도 순회가 가능하다.
- next를 진행시켰을 때 순회상태를 저장하고 있다.

이를 개선하기 위해서는

```
const iterable = {
  [Symbol.iterator] () {
    let i = 3;

    return {
      next () { ... }
      [Symbol.iterator] () { return this; } // 이터레이터도 이터러블이 되도록 만든다.
    }
  }
}
```

이터레이터를 for of 의 대상으로 넘겼을 때, for of는 `[Symbol.iterator]()` 로 이터레이터에게 '이터레이터를 줘!' 라고 말할테고 이터레이터는 '내가 이터레이터야!' 라고 하며 this로 참조된 자신를 내어준다. 그러므로 문제가 해결된다.

순회상태는 어떻게 저장되는가? 이터레이터가 생성될 때 next 메서드가 참조하고 있는 i와의 클로저가 형성되어있다. 따라서 자연스럽게 next로 변경된 순회상태는 i에 저장되어 있고, 이후 이터레이터를 for of로 순회하게 되면 저장된 상태를 클로저로 참조하고 있는 그 자신을 또 다시 순회하기 때문에 우리가 가졌던 두 가지 문제를 해결한 `well-formed iterator` 를 만날 수 있게 되는 것이다.

- 이터레이터/이터러블 프로토콜은 많은 곳에서 사용되고 있다!

페이스북의 immutable이나 DOM API로 가져오는 NodeList에도 이러한 인터페이스가 공통적으로 적용되어 있다.

- for of뿐 아니라 전개연산자 (spread operator) 도 이터레이터/이터러블 프로토콜을 사용한다

```

const arr = [1, 2, 3];

arr[Symbol.iterator] = null

console.log([...a]) // TypeError: arr is not iterable

```

### 제너레이터와 이터레이터

제너레이터는 이터레이터를 생성하는 함수이다. 생성되는 이터레이터는 위에서 알아본 well-formed iterator 이다.

```
function *gen () {
  yield 1;
  yield 2;
  yield 3;

  return "iteration is over";
}

const iterator = gen();

iterator.next(); // { value: 1, done: false }
iterator.next(); // { value: 2, done: false }
iterator.next(); // { value: 3, done: false }
iterator.next(); // { value: "iteration is over", done: true }
```

- odds

10보다 작은 홀수까지 출력할 수 있는 이터레이터를 생성하는 제너레이터를 작성해보자. (A를 위한 B를 만드는 C를 만드는 나..)

```
  function *limit (length, iterator) {
    let i = 0;

    for (i of iterator) {
      yield i;

      if (i === length) return;
    }
  }

  function *infinity (i = 0) {
    while (true) yield i++;
  }

  function *odds (iter) {
    for (i of iter) {
      if (i % 2 !== 0) yield i;
    }
  }

  const iter = odds(limit(10, infinity(1)));

  iter.next();
  iter.next();
  iter.next();

  for (i of iter) {
    console.log(i);
  }
```

limit과 infinity만을 사용하면 limit까지 순회가능한 수열을 쉽게 만들 수 있다.
거기에 odds를 추가하면 홀수만을 쏙 빼서 순회할 수 있는 이터레이터를 만들어 사용할 수 있다!

_제너레이터 함수를 조합하고 조합해서 원하는 이터레이터를 만들 수 있다는 것_ 이 핵심.

- for of, 전개연산자, 구조분해, 나머지연산자

이터러블 프로토콜을 따르고있는 문법들이다. 위에서 배운 이터레이터들을 잘 활용(consume)할 수 있다.

## map, filter, reduce

- map

```
const map = (arr, cb) => {
  const result = [];

  for (el of arr) {
    result.push(cb(el));
  }

  return result;
}

map([1, 2], (el) => el + 3);
```

- 이터러블 프로토콜을 따른 map의 다형성

위에서 만든 map은 매우 다형성이 높다. 사실상 모든 것들을 mapping 할 수 있다.

```
// querySelector로 가져온 nodeList는 이터러블이기에 map이 가능하다
map(querySelectorAll("div"), (el) => console.log(el));

// 이터레이터를 반환하는 제너레이터는 물론이다
function *gen () {
  yield 2;
  yield 3;
  yield 4;
}

map(gen(), (el) => el * el);
```

```
const m = new Map();
m.set("a", 1);
m.set("b", 2);

map(m, ([k, v]) => [k, v * 2]);
```

결론적으로 매우 활용도가 높다고 할 수 있겠다.

- filter

```
function *infinite (i = 0) {
  while (true) {
    yield i;

    i++;
  }
}

function *limit (length, iter) {
  for (i of iter) {
    yield i;

    if (i === length) return;
  }
}

const filter = (iterator, cb) => {
  const result = [];

  for (el of iterator) {
    if (cb(el)) result.push(el);
  }

  return result;
};

filter(limit(20, infinite()), el => el % 2 !== 0);
```

- reduce

초깃값이 전달되지 않았을 때, 이터러블 또는 이터레이터로 예상되는 것에게서 Symbol.iterator를 통해 이터레이터를 추출하고,
next를 통해 이터러블의 첫번째 값을 accumulator에 할당해 연산을 시작하도록 만들었다.

```
const arr = [1, 2, 3];

const reduce = (iter, cb, init) => {
  let acc = init;

  if (!acc) {
    const iterator = iter[Symbol.iterator]();
    const { value } = iterator.next();

    acc = value;
  }

  for (el of iter) {
    acc = cb(acc, el);
  }

  return acc;
};

reduce(arr, (acc, el) => {
  return acc * el;
});
```

- 함수형 사고

굉장히 선언적이다. 난 A를 하고싶은데, 그러려면 B가 필요하고, B를 만들기 위해서는 C가 필요하고..
마치 영어 문장을 작문하는 느낌으로 코딩할 수 있다.
아래에 작성한 코드는 위에서 말한것처럼 왼쪽에서 오른쪽으로 쭉 작성되었다. 마치 말하듯..

```
const add = (a, b) => a + b;

const sum = reduce(add, map(product => product.price, filter((product) => product.price <= 20000, products)));
```

### 코드를 값으로 다루어 표현력 높이기 (go, pipe)

- go

나의 안보고 첫 구현..

```
const go = (...params) => {
  let result;

  for (param of params) {
    // 함수라면 실행하고 결과라면 다음으로 넘긴다
    if (typeof param === "function") {
      result = param(result);
    } else {
      result = param;
    }
  }

  return result;
};

go(
  0,
  a => a + 1,
  a => a + 10,
  a => a + 100,
  console.log
);
```

인동님의 구현

```
const go = (...args) => reduce(args, (a, f) => f(a));
```

구현하고 생각해보니 어차피 go의 첫 인자는 함수가 아닌 값으로 들어와야하고, 그걸 reduce가 대신해주고 있다는걸 알게되었다.

- pipe

먼저 혼자 구현한 것.

pipe에 제공된 함수의 리스트를 실행할 수 있는 함수를 반환한다.
이후 해당 함수가 인자(arguments, args)와 함께 호출되었을 때,
process는 인자를 넘겨받으며 재귀적으로 호출되며, 호출할 함수의 순서를 기억하는 변수 i는 클로저로 기억된다.
process가 재귀적으로 호출될 때마다 i가 더해지며 다음 함수를 호출할 수 있고, 더 이상 호출할 수 있는 함수가 없을 때 결과를 반환한다.

```
const pipe = (...funcs) => {
  let i = 0;

  const process = (...args) => {
    const result = funcs[i](...args);

    if (!funcs[i + 1]) return result;

    i++;

    return process(result);
  }

  return (...args) => {
    return process(...args);
  }
}

const piped = pipe(
  a => a + 1,
  a => a + 10,
  a => a + 100
);

console.log(piped(1000));
```

그러나 인동님은 go를 괜히 구현한 것이 아니었다(..)

```
  const pipe = (func, ...funcs) => (...args) => go(func(...args), ...funcs);
```

---

중간 연습..reduce, go, pipe 순서로.

```
const reduce = (f, iter, init) => {
  let result;
  const iterator = iter[Symbol.iterator]();

  if (!init) {
    const { value } = iterator.next();

    result = value;
  } else {
    result = init;
  }

  for (el of iterator) {
    result = f(result, el);
  }

  return result;
}

const go = (...args) => reduce((acc, func) => func(acc), args);

const pipe = (...funcs) => {
  return (...args) => {
    return go(...args, ...funcs);
  };
}

const add3210 = pipe(
  (a) => a + 10,
  (a) => a + 200,
  (a) => a + 3000
);

const result = add3210(1);
```

---

- go + curry를 함께 사용해 가독성을 높여보자

먼저 커리를 구현해본다.
커리는 전달받은 함수의 인자가 함수의 매개변수의 갯수보다 덜 전달되었을때는 부분적으로 인자가 적용된 함수를 반환하여 평가를 미루는 기능을 제공한다.

_인동님 예제코드는 1개의 인자만 커링이 가능하도록 짜여져있어서 초기 함수의 매개변수 만큼 커링이 반복될 수 있도록 재귀로 변경시켰다!_

```
const curry = func => (...args) => args.length === func.length ? func(...args) : (...rest) => curry(func)(...args, ...rest)
```

..조금 펼쳐서 작성하자면

```
const curry = (func) => {
  return (...args) => {
    if (func.length === args.length) {
      return func(...args);
    }

    return (...rest) => {
      return curry(func)(...args, ...rest);
    }
  }
}
```

---

curry와 함께 전체 연습! (map, reduce, filter, go, curry)

```
const products = [
  {
    name: "t-shirt",
    price: 10000,
  },
  {
    name: "shirt",
    price: 20000,
  },
  {
    name: "trouser",
    price: 30000,
  }
];

const map = (f, iter) => {
  const result = [];

  for (i of iter) {
    result.push(f(i));
  }

  return result;
};

const filter = (f, iter) => {
  const result = [];

  for (i of iter) {
    if (f(i)) result.push(i);
  }

  return result;
};

const reduce = (f, iter, init) => {
  const iterator = iter[Symbol.iterator]();
  let result = init ? init : iterator.next().value;

  for (i of iterator) {
    result = f(result, i);
  }

  return result;
};

const curry = (func) => {
  return (...args) => {
    if (func.length === args.length) {
      return func(...args);
    }

    return (...rest) => {
      return curry(func)(...args, ...rest);
    }
  }
}

const mult = curry((a, b, c) => a * b * c);
const result = mult(3)(5)(10);

console.log(result);

// go는 값과 함수들을 받아 왼쪽부터 오른쪽으로 평가한 결과를 반환한다.
const go = (...args) => reduce((result, f) => f(result), args);

// 1. go를 사용하지 않았을 때
reduce(
  (sum, price) => sum + price,
  map(products => products.price,
  filter(product => product.price <= 20000, products))
);

// 2. go를 사용했을 때
go(
  products,
  (products) => filter(product => product.price <= 20000, products),
  (products) => map(product => product.price, products),
  (prices) => reduce((sum, price) => sum + price, prices)
);

// 3. curriable한 map, filter, reduce와 go를 함께 사용했을 때
const [curriableMap, curriableFilter, curriableReduce] = map(curry, [map, filter, reduce]);

go(
  products,
  curriableFilter(product => product.price <= 20000),
  curriableMap(product => product.price),
  curriableReduce(sum, price => sum + price)
);

// 4. 함수를 조합시켰을 때
const totalPrice = pipe(map(p => p.price), reduce(add));
const baseTotalPrice = predi => pipe(filter(predi), totalPrice); // predi는 predicate의 줄임으로 '조건자' 라는 의미이다.

go(
  products,
  baseTotalPrice(product => product.price <= 20000),
  console.log
);
```

---

## 지연성(Laziness) 1

### 1. range, 느긋한(Lazy) range

호출하는 동시에 배열을 생성하는 range 함수와 달리,
느긋한 L.range는 지연성을 가지고 나중에 - 순회될 때 평가된다.

```
const range = (length) => {
  const result = [];

  i = -1;
  while (++i < length) { // i+1 이 length보다 작을때에만 실행된다.
    result.push(i);
  }

  return result;
};

console.log(range(5));

const L = {};

L.range = function *(length) {
  let i = -1;

  while (++i < length) {
    yield i;
  }
};

for (i of L.range(10)) {
  console.log(i);
}
```

```
console.time("");
go(
  range(10000),
  take(5),
  reduce(add),
  console.log
);
console.timeEnd("");

console.time("");
go(
  L.range(10000),
  take(5),
  reduce(add),
  console.log
);
console.timeEnd("");

```

### 2. 제너레이터/이터레이터 프로토콜로 구현하는 지연 평가 (L.map, L.filter)

"가장 필요한 때까지" 평가를 미룬다.

```
L.map = function * (f, iter) {
  for (const i of iter) {
    yield f(i);
  }
}
```

```
L.filter = function * (f, iter) {
  for (const i of iter) if (f(a)) yield a;
}
```

### 3. 제너레이터로 생성된 L 메서드 시리즈의 평가 순서는 어떨까?

```
go(
  L.range(10),
  L.map(n => n + 10),
  L.filter(n => n % 2),
  take(2),
  log
)
```

실행하면 어떤 순서로 평가될까?

먼저 take부터 호출된다. take 내부에서 `iter.next()` 로 인해 이터레이터가 평가되는 시점에 - 그 이터레이터는 L.filter로부터 생성된 것이므로 - L.filter로 제어권이 넘어간다.

이후 L.filter 내부에서는 그에게 전달되었던 이터레이터를 평가하는 `iter.next()` 가 호출되는데, 해당 이터레이터는 L.map이 전달해준 것이므로 또다시 제어권은 L.map에게 넘어가게 된다.

마찬가지 과정을 통해 통제권은 또다시 L.range에게로 최종적으로 넘어간다. 이후 range에서는 yield되고, 이 값을 map에서 f(i)에 넘겨 yield, filter에서도 f(i)로 평가해서 yield 여부를 결정한다.

그러니까 위와 같은 코드에서 Lazy하지 않은 메서드들을 호출했다고 생각할때에는 왼쪽에서 오른쪽으로 한번에 쭈루룩 내려오는 방식으로 평가가 이루어지는 반면, Lazy한 제너레이터 메서드들로 구성된 경우에는 각 순회마다 위에서 아래로, 세로방향으로 평가가 반복적으로 이루어진다는 것이다.

중요한 점은, 이러한 평가 순서에 의해 성능이 크게 차이날 수 있다는 것. 예를 들어 range에 전달되는 수가 100000 정도로 충분히 크다고 할 때, Lazy한 경우에는 2번의 위에서 아래로의 순회로 take(2)가 완료될 수 있는 반면 Lazy 하지 않은 메서드의 연결에서는 먼저 map을 100000번, filter를 또 그만큼, 완료하고 난 후에야 2개를 take할 수 있는 기회를 가지게 되므로 매우 큰 연산 횟수의 차이가 나게 된다.

### 4. map / filter의 결합법칙

[[mapping, mapping], [filtering, filtering], [mapping, mapping]]

[[mapping, filtering, mapping], [mapping, filtering, mapping]]

## 지연성(Laziness) 2

### 1. reduce / take는 결과를 만든다

맵 필터와는 달리 이들은 결과를 만드는 역할을 하기에 지연평가될 수 없다.

객체로부터 queryString을 생성하는 함수를 리듀스를 사용해 만들어보자.

```
const queryStr = obj => go(
  obj,
  Object.entries,
  entries => map(([k, v]) => `${k}=${v}`, entries),
  qs => reduce((result, cur) => `${result}&${cur}`, qs)
);
```

두번째는 reduce를 사용해 join을 직접 구현해보자.
map과 reduce에는 커리를 적용해 합성 시 깔끔하게 작성할 수 있도록 만들었다.

```
const join = (separator, iter) => reduce((a, b) => `${a}${separator}${b}`, iter);

const createQueryString = pipe(
  obj,
  Object.entries,
  map(([k, v]) => `${k}=${v}`),
  join("&")
);

const qs = createQueryString({ limit: 10, offset: 10, type: "notice" });

console.log(qs);
```

우리가 작성한 join은 이터러블 프로토콜을 따르므로 Array 이외의 이터러블들에 적용될 수 있고, '다형성이 높다' 고 말할 수 있다. (다형성이란 도대체 뭘까..)

```
L.entries = (obj) => {
  for (const k in obj) yield [k: obj[k]];
}
```

---

### 또다시 찾아온 연습세션..

또 다시 연습해봤다. 이번에는 거꾸로, createQueryString 부터 작성을 시작해서
그에 필요한 pipe를 구현하고,
map을 구현하고,
join을 구현하기 위해 reduce를 구현하고,
join을 구현하고,
이들에 커리를 적용시키기 위해 curry를 구현하는 방식으로
마치 연어처럼..함수가 호출되는 순서로 거슬러 올라가며 구현을 연습해 보았다.

[<img width="848" alt="스크린샷 2023-07-15 오전 1 40 48" src="https://github.com/nninnnin/febase/assets/34882520/276588db-f72e-4670-bfb8-4e140fbf294f">
](https://www.youtube.com/watch?v=_JDBr6og7gM)

---

### 잠깐! Curry의 구현에 관하여

인동님이 구현한 커리는..

- 한번에 2개 이상의 인자를 커링할 수 없다.
- 2번 이상 커링할 수 없다.

코드로 확인해보자.

```
const adds = curry((a, b, c) => a + b + c);

adds(1)(2, 3) // 정상적으로 작동한다
adds(1, 2)(3) // 작동하지 않는다 (한번에 2개 이상의 인자를 커링할 수 없다)
adds(1)(2)(3) // 작동하지 않는다 (2번 이상 커링할 수 없다)
```

이러한 단점들을 보완하기 위해 재귀적으로 커링할 수 있도록 구현했다.

```
const curry = (func) => {
  return (...args) => {
    if (func.length === args.length) {
      return func(...args);
    }

    return (...restArgs) => {
      const curriedArgs = [...args, ...restArgs];
      return curry(func)(...curriedArgs);
    }
  }
}
```

해당 코드의 구현 시 재귀적 사고가 조금 힘든 경향이 있다.

[여기에서](https://medium.com/@juliomatcom/an-elegant-and-simple-curry-f-implementation-in-javascript-cf36252cff4c) 아래와 같은 코드도 찾을 수 있었다.
동일한 로직이지만 bind와 apply를 사용해 조금 더 간결하고,
복리적으로(?) 나머지 인자들을 적용하는 방식이 명료하게 느껴진다.

```
function curry(f) {
  return function currify() {
    const args = Array.prototype.slice.call(arguments);

    return args.length >= f.length ?
      f.apply(null, args) :
      currify.bind(null, ...args)
  }
}
```

내 방식대로 적용해보았다.

```
const curry = (func) => {
  return (...args) => {
    if (func.length === args.length) {
      func(...args);
    }

    return curry(func.bind(null, ...args));
  }
}
```

축약하면 아래처럼 쓸 수도 있다.

```
const curry = (func) => (...args) => func.length === args.length ? func.apply(null, args) : curry(func.bind(null, ...args));
```

bind를 활용한 방식이 더 명확하게 느껴진다. 또 다시 curry에 함수를 던지면서 이번에 받은 인자들을 바인딩해 던진다, 그러면 커리는 바인딩된 인자들의 갯수 + 다시 호출되며 추가된 인자들의 갯수를 합해 내놓을 결과를 판단할 수 있게 된다.

---

### 2. take, find

```
const users = [
  { age: 32 },
  { age: 31 },
  { age: 37 },
  { age: 28 },
  { age: 25 },
  { age: 31 }
];

const find = (f, iter) => go(
  iter,
  L.filter(f),
  take(1),
  ([a]) => a
);
```

### 3. L.map과 take로 map 만들기

```
L.map = curry(function * (f, iter) {
  for (i of iter) {
    yield f(i);
  }
});

const map = pipe(
  L.map,
  take(Infinity)
);
```

### 4. flattening 2d array

#### 4.1 flatten, L.flatten

```
const isIterable = a => a && a[Symbol.iterator];

L.flatten = function * (iter) {
  for (a of iter) {
    if (isIterable(a)) {
      for (b of a) {
        yield b;
      }
    } else {
      yield a;
    }
  }
}

const flatten = pipe(L.flatten, takeAll);
```

`yield *` 을 활용하면 flatten의 이중 `for of` 를 간단하게 작성할 수 있다.

```
L.flatten = functioon * () {
  for (a of iter) {
    if (isIterable(a)) yield *a;
    else yield a;
  }
}
```

대박~

#### 4.2. L.deepFlat

flatten을 재귀호출하고 앞에서 배운 `yield *`를 조합하면 deepFlat을 구현할 수 있다.

```
L.deepFlat = function * lazyDeepFlat(iter) {
  for (i of iter) {
    if (isIterable(i)) yield *lazyDeepFlat(i)
    else yield i
  }
}
```

#### 4.3. flatMap, L.flatMap

flatMap을 처음 접한 입장에서 헷갈리는 것은

먼저 flatten 시켜주고 난 값을 mapping하는데에 사용할 수 있구나!

인데 전혀 반대이다. flatMap에 전달되는 함수는 먼저 iterable에 대해 매핑될 때 사용되고, 이후 flatten이 진행된다.

따라서 만일 전달되는 배열들의 원소가 `const nestedArr = [1, 2, [3, 4], 5, 6]` 처럼 깊이가 섞여있다면,

`go(nestedArr, L.flatMap(a => a * a), takeAll)` 을 했을 때 `[2, 4, NaN, 25, 36]` 이 될테다.

```
L.flatMap = pipe(L.map, L.flatten);
```

- 이차원 배열을 다루어보자

```
const arr = [
  [1, 2],
  [3, 4, 5],
  [6, 7, 8],
  [9, 10]
];

go(
  arr,
  L.flatten,
  L.filter(a => a % 2),
  console.log
);
```

### 실무에서는 어떻게 사용될까?

```
const users = [
  {
    name: "Justin",
    age: 32,
    family: [
      { name: "James", age: 50 },
      { name: "Haden", age: 34 }
    ]
  },
  {
    name: "Harmon",
    age: 70,
    family: [
      { name: "Wengle", age: 30 },
      { name: "Hel Hommie", age: 24 },
      { name: "Waden", age: 42 },
      { name: "Galdon", age: 12 }
    ]
  },
  {
    name: "Wikken",
    age: 30,
    family: [
      { name: "Akden", age: 5 },
      { name: "Tolen", age: 14 },
      { name: "Holden", age: 33 }
    ]
  },
  {
    name: "Ragner",
    age: 16,
    family: [
      { name: "Dan", age: 20 },
      { name: "Loger", age: 49 }
    ]
  }
];

go(
  usersWithFamily,
  L.map(user => user.family),
  L.flatten,
  L.filter(user => user.age < 20),
  takeAll
);
```

## 비동기, 동시성 프로그래밍 1

### 1. Promise는 비동기 상황을 값으로 만들어 제어할 수 있도록 해준다

Promise 가 등장하기 전, 콜백으로 비동기 상황을 제어할 수 있던 시절에는 콜백의 콜백의 콜백의 콜백의...에 모든 상황 이후의 동작들을 표기해주는 방식으로 비동기적인 처리를 제어했다.
Promise를 사용하면서, 비동기적 진행상황을 Promise라는 객체 안에 가둘 수 있게 되었고 이 상황 자체를 객체로 요리조리 컨트롤 할 수 있게 된 것이다.

### 2. 모나드?

함수합성을 안전하게 해주는 것을 돕는다. (고 한다..)

```
const f = (a) => a + 1;
const g = (a) => a * a;

f(g(2));
f(g()); // NaN : 안전하지 않다

[2].map(g).map(f);
[].map(g).map(f); // Nothing happend: 안전하다

Array.of(2).map(g).map(f);
Promise.resolve(2).then(g).then(f); // 비동기적으로 일어나는 상황을 안전하게 합성, 단 위에서는 값의 유무를 안전성으로 보았다면 이는 비동기적인 상황의 처리(타이밍)를 안전성으로 고려한다.
```

### 3. Kleisli Composition

오류가 있을 수 있는 상황에서의 함수합성을 안전하게 돕는 하나의 규칙

```
const users = [
  { id: 1, name: "Justin" },
  { id: 2, name: "Walter" },
  { id: 3, name: "Sweit" },
];

const getUsername = user => user.name;
const getUserById = id => find(user => user.id === id, users) || Promise.reject("User is not found!");

const getUsernameById = id => Promise.resolve(id).then(getUserById).then(getUsername).catch(err => err);
```

주목할 부분은 getUserById의 find가 실패했을 때, Promise.reject를 대신 반환하면서 catch로 합성된 함수의 에러를 잡을 수 있도록 처리했다는 점.

### 4. go, pipe, reduce에서의 비동기 제어

```
go(
  1,
  a => a + 1,
  a => Promise.resolve(a * 10),
  a => a + 100,
  a => a + 1000,
  a => a + 10000
)
```

위와 같이 Promise가 중간에 끼워져있을 때, 일단 go는 내부적으로 reduce를 사용하고 있고 reduce에서는 Promise를 처리하고 있지 않으므로 원치않는 결과가 나올 것.

이를 해결하기 위해 reduce를 아래와 같이 고쳐줄 수 있다.

```
const reduce = (f, iter, init) => {
  let result = init;
  iter = iter[Symbol.iterator]();

  if (!init) {
    result = iter.next().value;
  } else {
    result = init;
  }

  for (const i of iter) {
    result = result instanceof Promise ? result.then(res => f(res, i)) : f(result, i);
  }

  return result;
};
```

자바스크립트 엔진에서의 작동은 아래의 그림과 같을 것이다.

<img width="955" alt="스크린샷 2023-07-15 오전 2 38 01" src="https://github.com/nninnnin/febase/assets/34882520/4ba11f23-91b8-4a6f-a600-556c4ad28ecf">

그러나 이렇게 작성하면 - 그림을 참고해 코드가 작동하는 방식을 생각해보면,
then에 then을 반복하는 프로미스 체인을 호출하게 되는데,
그러면 비동기 작업을 미뤄두는 task queue과 이벤트룹을 거쳐 콜스택에 들어와 함수들이 실행된다.

그렇지 않고 동기적으로 결과를 전달할수는 없을까?

코드를 작성하기 전, 먼저 생각해보자.

result.then으로 전달되는 f(res, i)를 다시 result로 데려올 수 있다면?
그냥 result를 f(res, i)로 할당하면 되는거 아니야? 라고 생각했다면, 아주 잘못된 생각이다. 비동기적으로 실행되는 함수의 결과 `f(res,i)` 만이 마지막에 할당되어 반환될 것이다.

f(res, i)의 결과를 result로 다시 가져와서 순회를 이어가기 위해서 재귀를 사용해야겠구나, 라는 생각까지 이어질 수 있다. 코드를 작성해보자. 먼저 재귀적으로 작성하고 싶은 부분을 함수로 변경한다.

```
const reduce = (f, iter, init) => {
  let result = init;
  iter = iter[Symbol.iterator]();

  if (!result) {
    result = iter.next().value;
  }

  return (function recur (result) {
    for (i of iter) {
      if (result instanceof Promise) {
        result.then(res => f(res, i));
      } {
        result = f(result, i);
      }
    }

    return result;
  })(result);
}
```

iterator를 순회하고 result를 반환하는 부분을 따로 recur 함수로 분리해 작성한다.

이렇게 바꿈으로서, iterator는 소비된 상태로 계속해서 순회할 수 있으며
then의 결과인 result를 재귀함수 recur의 인자로 넘겨 더 이상 then 체이닝을 하지 않아도
이후의 non-promise returning 함수들을 동기적으로 실행할 수 있도록 만들 수 있게 된다.

```
const reduce = (f, iter, init) => {
  let result = init;
  iter = iter[Symbol.iterator]();

  if (!init) {
    result = iter.next().value;
  } else {
    result = init;
  }

  function recur (result) {
    for (const i of iter) {
      if (result instanceof Promise) {
        return result.then(res => f(res, i));
      } else {
        result = f(result, i);
      }
    }

    return result;
  }

  return recur(result);
};
```

생각해보면, 위의 코드와 달리 중간에 Promise가 한번 걸렸다 하더라도 그 후의 로직들은 then 체인이 아닌 동기적으로 처리되는 것을 알 수 있다.
비동기 시행에 의한 taskQueue를 한번만 거쳐도 되는것이다.

<img width="872" alt="스크린샷 2023-07-15 오전 2 37 39" src="https://github.com/nninnnin/febase/assets/34882520/699a550b-90f5-442c-8b58-bf66f147efd6">

- Promise는 중첩되어도 한번에 값을 꺼낼 수 있다

```
Promise.resolve(Promise.resolve(Promise.resolve(10))).then(res => console.log(res));
```

- Promise, L.map과 take

```
const go1 = (args, func) => args instanceof Promise ? args.then(func) : func(args);

L.map = function * (func, iter) {
  for (const i of iter) {
    yield go1(i, func);
  }
}

const take = (l, iter) => { // 3, [P1, P2, P3]
  const result = [];
  iter = iter[Symbol.iterator]();

  let current = iter.next();

  return (function recur () {
    while (!current.done) {
      if (result.length === l) return result;

      if (current.value instanceof Promise) {
        return current.value.then(res => {
          result.push(res);
          current = iter.next();

          return recur();
        });
      }

      result.push(current.value);
      current = iter.next();
    }

    return result;
  })();
};

go(
  [Promise.resolve(1), Promise.resolve(2), Promise.resolve(3)],
  L.map(a => a + 10), // [object Promise]10 을 보고싶지 않다면, 내부적으로 go1을 사용해주어야 한다
  take(2),
  console.log
);
```
