---
title: 프론트엔드 클린코드
category: tech
---


# 프론트엔드 클린코드

<iframe width="560" height="315" src="https://www.youtube.com/embed/edWbHp_k_9Y" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>

별 다른 내용은 없고, 영상 내용을 혼자 정리하기 위해 작성해본다.

해당 영상의 소갯말에서, 내용을 아주 명확하게 알려준다.

> 실무에서 클린 코드의 의의는 유지보수 시간의 단축입니다.
동료 혹은 과거의 스스로 짠 코드를 빠르게 이해할 수 있다면 유지보수할 때 드는 개발 시간이 짧아집니다.

> 실제 예시와 함께 `응집도`, `단일 책임`, `추상화` 총 세 가지 관점으로 클린코드 방법론을 공유합니다.

영상에서 가장 처음으로 제공되는 기본 코드는 다음과 같다.

```tsx
function QuestionPage () {
  const handleQuestionSubmit = async () => {
    const 약관동의 = await 약관동의_받아오기();
    
    if (!약관동의) {
      await 약관동의_팝업열기();
    }
    
    await 질문전송(questionValue);
    alert("질문이 등록되었어요.");
  }
  
  return (
    <main>
      <form>
        <textarea placeholder="어떤 내용이 궁금한가요?" />
        <Button onClick={handleQuestionSubmit}>질문하기</Button>
      </form>
    </main>
  );
}
```

영상에는 나오지 않지만, 보험에 대한 질문을 할 수 있는 textarea가 존재하고 질문을 입력해 '질문하기' 버튼을 누르면 질문이 등록되도록 구현되어 있는 페이지이다. 버튼을 누르면 작동하는 `handleQuestionSubmit` 함수는 약관 동의 여부를 확인하고 질문을 전송하고 alert을 띄우는 일들을 한다.

이 상황에서, 새로운 요구사항이 들어온다. 유저에게 연결된 보험설계사가 존재하는 경우에는 질문을 전송하기 전 설계사의 사진이 들어있는 팝업을 먼저 띄워달라는 요청이다.

아래는 해당 요청사항을 구현하기 위해 1차적으로 작성된 코드이다.

```tsx
function QuestionPage () {
  const [popupOpened, setPopupOpened] = useState(false); // 추가된 코드: 팝업과 관련된 상태가 추가되었다

  const handleQuestionSubmit = async () => {
    // 추가된 코드: 먼저 연결전문가의 존재를 확인하고 존재하면 팝업을 띄워준다
    const 연결전문가 = await 연결전문가_받아오기();
    
    if (연결전문가 !== null) {
      setPopupOpened(true);
      return;
    }
  
    const 약관동의 = await 약관동의_받아오기();
    
    if (!약관동의) {
      await 약관동의_팝업열기();
    }
    
    await 질문전송(questionValue);
    alert("질문이 등록되었어요.");
  }
  
  const handleMyExpertQuestionSubmit = async () => {
    await 연결전문가_질문전송(questionValue, 연결전문가.id);
    alert(`${연결전문가.name}에게 질문이 등록되었어요.`);
  }; // 추가된 코드: 팝업에서 확인 버튼을 눌렀을 때 실행
  
  return (
    <main>
      <form>
        <textarea placeholder="어떤 내용이 궁금한가요?" />
        <Button onClick={handleQuestionSubmit}>질문하기</Button>
      </form>
      {/* 추가된 코드 */}
      {popupOpened && <연결전문가팝업 onSubmit={handleMyExpertQuestionSubmit} />}
    </main>
  );
}
```

아주 일반적인 구현이다.
그러나 '유지보수에 적절한 코드인가?' 의 관점에서 세 가지의 문제점이 있다.

새로운 기능 구현을 위해 추가된 코드들의 위치를 살펴보면, QuestionPage 컴포넌트 함수 내부에 굉장히 산개되어 존재하고 있음을 확인할 수 있다. 이것을 `응집도가 낮다` 고 말할 수 있는데, 응집도가 낮은 코드는 추후에 해당 기능을 확인하고 수정해야할 때 개발자의 수고로움을 높여준다. 넓은 범위의 코드를 확인하며 내 관심사와 관계없는/관계있는 코드를 골라내어 읽어야만 하기 때문이다.

또한 `handleQuestionSubmit` 함수에는 연결전문가의 존재를 확인하고 팝업을 띄우는 동작이 추가되었는데, 이 때문에 해당 함수에서 `너무 많은 일들을 한꺼번에 처리`하게 되었다. 나누어보자면 1) 방금 추가된 연결전문가와 관련된 일, 2) 약관동의와 관련된 일, 3) 질문을 전송하는 일 세가지의 일을 하고 있다. 이렇게 하나의 함수에서 여러가지 일들을 동시에 처리하게 된다면, 해당 함수에서 어떤 일들을 처리하고 있는지 직접 모든 코드를 읽어 파악하지 않으면 안된다는 문제가 생긴다.

마지막으로 수정된 `handleQuestionSubmit` 과 새롭게 작성된 `handleMyExpertQuestionSubmit` 을 비교해보면, 함수의 이름만 보았을 때는 비슷한 수준의 일처리를 진행할 것 같지만 실제로 그 내부에서 처리하는 일들의 가짓수는 방금 알아보았듯 하나는 여러가지를 처리하고 있고 또 하나는 아주 간단한 일 하나만을 처리하고 있다. 같은 대리급 인원임에도(?) 3배 정도의 업무량 차이가 나는 것이다. 

이러한 문제들을 어떻게 해결할 수 있는지 살펴보자.

```
const QuestionPage = () => {
  const 연결전문가 = useFetch(연결전문가_받아오기);
  
  const openPopupToNotAgreedUsers = async () => {
    const 약관동의 = await 약관동의_받아오기();
    if (!약관동의) {
      await 약관동의_팝업열기();
    }
  };

  const handleNewExpertQuestionSubmit async () => {
    await 질문전송(questionValue);
    alert("질문이 등록되었어요");
  };

  const handleMyExpertQuestionSubmit = () => {
    await 연결전문가_질문전송(questionValue);
    alert(`${연결전문가.name}에게 질문이 등록되었어요.`);
  };

  return (
    <main>
      <form>
        <textarea placeholder="어떤 내용이 궁금한가요?" />
        {연결전문가.connected ? (
          <PopupTriggerButton
            popup={<연결전문가팝업 onSubmit={handleMyExpertQuestionSubmit} />}
          >
            질문하기
          </PopupTriggerButton>
        ) : (
          <Button
            onSubmit={() => {
              await openPopupToNotAgreedUsers();
              await handleNewExpertQuestionSubmit();
            }}
          >
            질문하기
          </Button>
        )}
      </form>
    </main>
  );
}
```
먼저, 두개의 이벤트 핸들러의 '세부 구현 단계' 를 통일한다.
기존의 `handleQuestionSubmit` 이라는 이름을 바꾸어 MyExpert~ 와 수준을 맞추어주고, 내부 동작도 결론적으로 해야하는 질문 전송 로직만을 남겨주어 하는 일의 수준도 맞춰주었다. 이제 둘은 같은 대리급으로 인정받을 수 있게 되었다.

다음으로 팝업과 관련된 코드를 하나로 뭉쳐 응집도를 높여준다.
`PopupTriggerButton` (이름이 적절한지는 조금 의문스럽다.) 이라는 이름으로 컴포넌트를 만들어주고, 해당 컴포넌트에 팝업 버튼을 정의한 뒤 팝업을 인터페이스로 제공받을 수 있도록 만들어주었다. 내부에서 띄워질 팝업 내용과 버튼을 클릭했을 때의 핸들러라는 두 가지의 의존성을 인터페이스를 통해 주입받을 수 있도록 구현했기 때문에 다른 곳에서도 유용하게, 유연하게 사용될 수 있을 것 같다.

마지막으로 이전의 `handleQuestionSubmit` 에서 행해지던 약관동의도 개별 함수로 분리해주었다. `openPopupToNotAgreedUsers` 라는 이름이다.

세가지 일들을 정리해보자면 이벤트 핸들러의 세부 구현단계를 통일해 추상화 단계를 조절해서 비슷하게 맞춰주었고 이를 통해 충분히 예상가능한 동작범위의 함수를 구현해 원하는 로직을 빠르게 찾을 수 있도록 돕는다. 동일한 목적을 가진 코드는 한 곳에 뭉쳐두어 또한 찾기 쉽도록 만들어주고, 단일책임 원칙에 의거해 함수를 쪼개줘서 세부구현을 파악하지 않아도 예측가능한 코드를 만들어준다.

모두 개발자로 하여금 코드의 구조를 이해하는 비용을 낮춰주어 생산성을 높일 수 있도록 도울 수 있는 일들이다. 응집도를 높이고, 추상화 수준을 비슷하게 정리하고, 하나의 일들만을 담당하게 만든다. 끝.